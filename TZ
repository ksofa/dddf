Техническое задание на Backend платформы «Taska» (без финансовой логики)
Описание платформы
Taska — агрегатор профессиональных digital-команд, объединяющий лучших специалистов отрасли для решения бизнес-задач. Для запуска проекта заказчику необходимо предоставить подробную информацию о своей задаче. Заполнить краткую форму можно на сайте или через Telegram-бот. После анализа заявки проектный менеджер подбирает оптимальный состав специалистов, с которыми утверждает детальный план работ и фиксирует сроки выполнения. Все параметры проекта согласовываются с заказчиком и фиксируются в договоре, гарантирующем выполнение обязательств обеих сторон. В результате заказчик получает решение, соответствующее всем требованиям и прошедшее необходимое тестирование.
Обзор архитектуры и технологий
Backend платформы Taska основан на облачной базе данных Firebase Firestore (NoSQL, документно-ориентированное хранилище) для хранения данных и обеспечения механизма реального времени. Для аутентификации пользователей применяется Firebase Authentication (с поддержкой email/пароля, а при необходимости OAuth-провайдеров). Реализация серверной логики может быть выполнена с помощью облачных функций Firebase (Cloud Functions) либо на выделенном сервере (например, Node.js с Express), который работает с Firestore через REST API. Система поддерживает несколько пользовательских ролей – Заказчик, Исполнитель, Проектный менеджер (ПМ), Пресейл-менеджер и Супер-админ. Один пользователь может обладать несколькими ролями одновременно. Доступ к функционалу и данным определяется ролевой моделью (role-based access control). Например, заказчик может создавать проекты и контролировать их выполнение; ПМ – управлять проектами и командой; исполнитель – получать приглашения и выполнять задачи; пресейл – назначать ПМ и курировать старт проектов; супер-админ – имеет полный административный доступ. Разграничение прав обеспечивает безопасность данных.
Реалтайм-синхронизация
Для некоторых функций платформы (чаты, доска задач и пр.) необходима мгновенная синхронизация данных между пользователями. Firestore обеспечивает из коробки обновления данных в реальном времени: фронтенд-клиент может подписаться на изменения коллекций или документов (через методы onSnapshot), и обновления (например, новые сообщения, изменение статуса задачи, получение уведомления) доставляются мгновенно без необходимости опроса. При использовании выделенного сервера дополнительно могут применяться WebSocket-соединения или другие механизмы (например, Firebase Realtime Database) для отправки событий, но в рамках данного решения предполагается опора на возможности Firestore для realtime-обновлений. Ниже представлены подробные спецификации API эндпоинтов (REST) и структуры базы данных, охватывающие все основные сценарии платформы — включая аутентификацию, управление проектами, командами, приглашениями, задачами (Scrum-доской), чатами и уведомлениями — без какого-либо платежного функционала. Все изменения в данных (проекты, задачи, сообщения, приглашения и т.д.) мгновенно синхронизируются у участников соответствующих проектов.
Роли и доступ
Заказчик: создает проекты, получает обновления о проектах, общается с ПМ в чате, согласовывает этапы проектов, получает уведомления (email/Telegram), просматривает информацию о проекте (Scrum-доска, документация), обращается в техническую поддержку.
Исполнитель: оценивает и принимает/отклоняет приглашения в команду проекта, выполняет задачи проекта (добавляет документы в проект, перемещает задачи на скрам-доске, пишет сообщения в чат), участвует в согласовании сроков и этапов (изменяет статусы задач на Scrum-доске).
Проектный менеджер (ПМ): управляет проектом от старта до сдачи, собирает команду (рассылает приглашения исполнителям), ведет Scrum-доску (добавляет/обновляет задачи, контролирует статусы), служит связующим звеном между заказчиком и командой (общается с заказчиком и исполнителями, координирует их работу), контролирует сроки и качество выполнения.
Пресейл-менеджер: имеет полный доступ ко всем данным платформы. Управляет пользователями и их ролями, а также глобальными настройками. Может просматривать и изменять любые проекты, команды, чаты. Также занимается управлением справочниками (например, категориями специализаций) и следит за системой уведомлений. (Финансовые функции супер-админа в данном контексте отсутствуют.)
API эндпоинты (REST & Realtime)
Ниже перечислены основные REST API эндпоинты платформы. Реaltime-события (обновление данных на клиентах) происходят автоматически при изменении соответствующих данных в Firestore, как описано в разделе синхронизации.
Аутентификация:
POST /auth/register – Регистрация нового пользователя (создание аккаунта).
POST /auth/login – Вход пользователя в систему (получение токена).
GET /auth/profile – Получить профиль текущего аутентифицированного пользователя. Возвращает данные аккаунта: ID, имя, email, роли, категории специализации и прочую информацию профиля. (Доступ: авторизованный пользователь).
Пользователи:
GET /users – Получить список пользователей. Используется в административном интерфейсе, например, для подбора исполнителей в команду. Поддерживает фильтрацию по роли и категории (например, можно запросить всех пользователей с ролью "Исполнитель" и категорией "Дизайнер"). (Доступ: пресейл, ПМ – для подбора команды; супер-админ.)
GET /users/{userId} – Получить информацию о конкретном пользователе (мини-профиль исполнителя: контакты, рейтинг, роли, категории и т.д.). (Доступ: участники общих проектов, пресейл, супер-админ.)
PUT /users/{userId} – Обновление данных пользователя. Сам пользователь может обновить свои личные данные (имя, контакты, аватар и пр.). Супер-админ или пресейл-менеджер с админ-правами может изменять роли пользователя и присваивать категории (например, назначить пользователю роль "Исполнитель" и указать его специализации, либо повысить пресейл-менеджера до супер-админа). (Доступ: владелец профиля может менять только свои данные; изменения ролей – только супер-админ или пресейл с соответствующими правами.)
Проекты:
POST /projects – Создание нового проекта. Этот запрос инициируется заказчиком (через форму заявки) или пресейл-менеджером от имени заказчика. В проект сохраняется основная информация: название, описание, заказчик, пресейл (куратор), и присваивается начальный статус (например, "Предпроект").
GET /projects – Получить список проектов, доступных текущему пользователю. Заказчик видит только свои проекты; ПМ – проекты, где он назначен менеджером; исполнитель – проекты, в которых он состоит в команде; пресейл – все проекты на этапах предпродажи/подбора команды; супер-админ – все проекты в системе. Эндпоинт поддерживает фильтрацию по статусу и этапу (для интерфейса можно передавать параметры фильтрации, например чтобы отобразить только проекты в работе или только завершенные). В ответ по каждому проекту возвращаются основные данные: ID, название, статус (например, "В работе", "Завершен"), текущий этап (номер или название), руководитель проекта (ФИО ПМ), клиент (ФИО заказчика), иконка/аватар проекта. (Доступ: авторизованные пользователи; каждый видит проекты в пределах своих прав).
GET /projects/{projectId} – Получить подробную информацию о проекте. Возвращает все детали проекта: описание, текущий статус, этапы (если разбит на этапы), ответственные лица (ПМ, пресейл-менеджер, заказчик), состав команды (список исполнителей с их данными), ссылки на проектную документацию, историю активностей. Также может включать агрегированную информацию: количество задач в проекте, прогресс выполнения задач, даты начала и окончания этапов. Этот эндпоинт используется для загрузки страницы детализации проекта (включая вкладки: Scrum-доска, Команда, Чат, Документация, История активностей). (Доступ: участники проекта — заказчик (после старта проекта), назначенный ПМ, исполнители команды, пресейл; супер-админ.)
PUT /projects/{projectId} – Обновление проекта. Используется для изменения статуса проекта или ключевых параметров. Например:
Пресейл-менеджер переводит статус с "Предпроект" на "Обработка пресейлом" после того, как взял заявку в работу.
Назначение ПМ: пресейл через этот же метод устанавливает поле pmId (ID выбранного проектного менеджера) и переводит статус на "Назначен ПМ".
ПМ, завершив подбор команды (и подготовив план работ), обновляет статус на "Команда подобрана".
Когда заказчик согласовал план проекта, статус изменяется на "В работе (Этап 1)" – проект запущен в работу, начиная с первого этапа.
По завершении каждого этапа ПМ обновляет статус. Например: "Этап 1 выполнен – ожидает приемки", и после подтверждения заказчиком – "Этап 1 принят", далее "Этап 2 (в работе)" и т.д., пока проект не получит финальный статус "Завершен".
Также через обновление проекта можно менять основную информацию: например, изменить название проекта (требует подтверждения пресейлом/ПМ), обновить описание, прикрепить дополнительные документы.
(Доступ: пресейл-менеджер и назначенный ПМ могут обновлять данные проекта; заказчик не может напрямую менять проект, только просматривать; супер-админ имеет право на любые изменения.)
DELETE /projects/{projectId} – Удаление проекта. Может использоваться для отмены заявки на этапе предпродакта (например, если заказчик передумал или пресейл отклонил проект до старта) либо для административного удаления. Этот вызов удаляет сам проект и связанные с ним поддокументы. (В Firestore можно реализовать каскадное удаление вложенных коллекций через Cloud Functions.) (Доступ: супер-админ; пресейл может удалить проект на ранней стадии, если проект не был запущен.)
Заявки (приглашения в команду):
POST /projects/{projectId}/team/invite – Отправить приглашение исполнителю присоединиться к команде проекта. Формирует новую заявку (invite) для указанного пользователя-исполнителя на проект. (Доступ: пресейл или ПМ данного проекта.)
GET /invites – Получить список приглашений (заявок). Для исполнителя возвращает приглашения, адресованные ему (входящие приглашения). Для менеджеров может возвращать приглашения по проектам, которые они ведут (например, чтобы отслеживать, кто принял/отклонил приглашение). (Доступ: авторизованные пользователи; каждый видит только релевантные приглашения).
GET /invites/{inviteId} – Просмотреть детали конкретной заявки-приглашения. Возвращает всю информацию: к какому проекту относится приглашение, описание задачи или роль, на которую приглашают исполнителя, и текущий статус приглашения. При первом просмотре приглашение может помечаться как «просмотренное». (Доступ: адресованный приглашением исполнитель; а также ПМ/пресейл проекта для просмотра статуса приглашения.)
PUT /invites/{inviteId}/respond – Ответ исполнителя на приглашение. Исполнитель может:
Принять приглашение – согласиться участвовать в проекте. Статус приглашения обновляется, например, на "Принято исполнителем" (ожидает подтверждения ПМ).
Отклонить приглашение – отказаться от участия. Статус меняется на "Отклонено исполнителем". Исполнитель при отклонении может добавить комментарий с причиной отказа (необязательно).
При вызове этого метода соответствующий документ приглашения в Firestore обновляется (меняется статус, добавляются дата ответа и пр.). Система в реальном времени уведомляет проектного менеджера о полученном ответе (список приглашений обновляется, генерируется уведомление для ПМ). (Доступ: только тот исполнитель, которому адресовано приглашение.)
PUT /invites/{inviteId}/accept – Решение менеджера по заявке исполнителя. Этот метод вызывается ПМ или пресейл-менеджером после того, как исполнитель ответил "Принято". Менеджер через этот эндпоинт либо утверждает исполнителя в команду, либо отклоняет его кандидатуру:
При утверждении приглашения статус меняется на "Принято ПМ". Данный исполнитель добавляется в состав команды проекта (например, его ID добавляется в поле команды проекта).
При отклонении кандидатуры статус приглашения меняется на "Отклонено ПМ". Исполнитель может получить уведомление о том, что его участие не подтверждено. После отклонения ПМ при необходимости приглашает другого исполнителя.
(Доступ: ПМ или пресейл, ведущие данный проект.)
Команды:
GET /projects/{projectId}/team – Получить текущий состав команды проекта. Возвращает список участников проекта (исполнителей) и, возможно, информацию о ролях каждого участника в проекте. (Доступ: участники проекта, пресейл, супер-админ.)
POST /projects/{projectId}/team – Добавить участника в команду проекта. (Альтернативный способ вне процесса приглашений – например, админ или пресейл могут напрямую добавить пользователя в команду при необходимости.) (Доступ: пресейл, супер-админ.)
DELETE /projects/{projectId}/team/{userId} – Удалить участника из команды проекта. Убирает исполнителя из списка команды проекта (например, если исполнитель покинул проект или был заменен). (Доступ: ПМ, пресейл, супер-админ.)
Scrum-доска (задачи):
GET /projects/{projectId}/tasks – Получить список задач проекта (колонки и задачи на Scrum-доске).
POST /projects/{projectId}/tasks – Создать новую задачу в проекте (в колонке "To Do" по умолчанию, либо указанной).
PUT /projects/{projectId}/tasks/{taskId} – Обновить задачу. Используется для редактирования описания, изменения колонки (перемещение задачи по доске), назначения исполнителя на задачу, изменения статуса и т.д.
DELETE /projects/{projectId}/tasks/{taskId} – Удалить задачу из проекта.
POST /projects/{projectId}/columns – Добавить новую колонку на Scrum-доску (например, новую стадию задач).
PUT /projects/{projectId}/columns/{columnId} – Обновить/переименовать колонку доски (например, изменить название или порядок).
GET /projects/{projectId}/activity – Получить историю активности по проекту. Возвращает журнал действий: изменения статусов задач, добавление документов, вступление/выход участников из проекта и прочие события. Используется для отображения ленты изменений (audit log) проекта.
Чаты:
GET /projects/{projectId}/chats – Получить список чатов, связанных с проектом. Обычно у каждого проекта есть один общий групповой чат для всей команды; при необходимости могут быть и дополнительные (например, личный чат между заказчиком и ПМ). Эндпоинт возвращает ID и информацию о чатах проекта (название чата, тип, участники и пр.). (Доступ: участники проекта.)
GET /chats/{chatId}/messages – Получить сообщения указанного чата. Обычно используется с пагинацией или загрузкой последних N сообщений для отображения чата. (Доступ: участники соответствующего чата.)
POST /chats/{chatId}/messages – Отправить новое сообщение в чат. Добавляет сообщение (текст или файл) в указанный чат и транслирует его в реальном времени другим участникам.
POST /chats/{chatId}/read – Пометить чат как прочитанный текущим пользователем (обновляет статус прочтения сообщений, чтобы сбросить непрочитанные сообщения для пользователя).
Уведомления:
GET /notifications – Получить список уведомлений текущего пользователя. Возвращает массив уведомлений (непрочитанные обычно первыми или помечены флагом). Уведомления охватывают различные события, описанные ниже. (Доступ: авторизованный пользователь, только свои уведомления).
POST /notifications/mark-read – Пометить уведомления как прочитанные. Может отмечать одно или несколько уведомлений прочитанными (например, отправляется список ID уведомлений или признак "отметить все"). После этого соответствующие уведомления не показываются как новые пользователю.
Структура Firestore (Firebase)
Ниже описана структура хранения данных в Firestore, коллекции и основные поля документов. Имена коллекций и полей даны условно для понимания модели.
users – коллекция пользователей.
Поля документа пользователя: fullName (ФИО), email, roles (массив ролей пользователя), categories (список категорий/специализаций пользователя), profileImage (URL аватара), contactInfo (контактные данные), createdAt (метка времени регистрации).
Подколлекции:
notifications – уведомления пользователя. Каждое уведомление хранится как отдельный документ (например, с полями: type или title, message/text, projectId/inviteId для связи с сущностью, createdAt, read и пр.).
projects – коллекция проектов.
Поля документа проекта: title (название), description (описание), status (статус проекта, строка или код), stage (текущий этап проекта, номер или название), customerId (ID заказчика), presaleId (ID пресейл-менеджера, курирующего проект на старте), pmId (ID назначенного проектного менеджера), team (массив ID исполнителей, участников команды), createdAt (дата создания проекта), iconUrl (ссылка на иконку или аватар проекта).
Подколлекции:
tasks – задачи проекта (Kanban-доска). Каждая задача – отдельный документ:
Поля задачи: text (текст/описание задачи), column (ID или название колонки, в которой задача находится), assignee (ID исполнителя, которому задача назначена, или null если не назначена), status (статус задачи, например, "to-do" / "done" или иное, опционально дублирует состояние колонки), color (цветовая метка задачи, строка-код цвета, если используется), dueDate (дедлайн, timestamp, если есть), createdBy (ID пользователя, создавшего задачу), createdAt, updatedAt. При необходимости могут быть поля для вложений: например, attachmentUrl (URL прикрепленного файла) или link (ссылка).
columns – колонки доски. Документ колонки содержит: name (название колонки, например "To Do", "In Progress", "Done"), order (порядковый номер колонки для сортировки/отображения).
activity – история активности проекта. Каждый документ представляет одно событие: поля могут включать timestamp (время события), userId (кто совершил действие), action (код или название действия), details (описание детали, например, "статус задачи 'XYZ' изменен на 'Готово'"). Вся история хранится унифицировано в одной коллекции, при необходимости можно фильтровать по типам действий (задачи, приглашения и др.).
documents – документы/файлы проекта. Документ файла содержит: name (имя файла), fileType (тип/формат, например "pdf" или MIME-тип), size (размер в байтах), uploadedBy (ID пользователя, загрузившего файл), uploadedAt (время загрузки), url (ссылка для скачивания файла из облачного хранилища), storagePath (внутренний путь в хранилище для управления, удаления и т.п.).
chats – чаты, связанные с проектом. Каждый документ чата описывает отдельный чат (например, общий групповой чат проекта или личный чат):
Поля чата: type (тип чата: "group" – групповой для проекта или "direct" – личный между двумя пользователями), name (название чата, напр. "Общий чат проекта" или идентификатор для direct-чата), participants (массив ID участников чата), createdAt (дата создания чата). При хранении как глобальной коллекции, документ чата также содержит projectId для привязки к проекту.
Подколлекция: messages – сообщения чата. Каждое сообщение – документ с полями: senderId (ID отправителя), text (текст сообщения), timestamp (время отправки), type (тип сообщения: например, "text" или "file"), fileUrl (если тип файла – ссылка на вложение), и др. (например, статус прочтения, но обычно прочтение отслеживается отдельно).
invites – коллекция приглашений (заявок в команду проекта). (Вместо подколлекций в проектах, приглашения хранятся глобально для удобства запросов). Документ приглашения включает поля: projectId (ID проекта, к которому относится приглашение), executorId (ID пользователя-исполнителя, которому отправлено приглашение), status (статус заявки: например, "pending"/"sent", "viewed", "accepted_by_executor", "declined_by_executor", "accepted_by_pm", "declined_by_pm"), createdBy (ID пользователя, создавшего приглашение – обычно ПМ или пресейл), createdAt (дата создания приглашения), responseAt (дата ответа исполнителя, если ответ получен), acceptedByPmAt (дата решения ПМ по заявке, если принято/отклонено). (Поля estimatedTime и estimatedCost из оригинальной схемы удалены вместе с логикой оценки стоимости.)
categories – коллекция категорий/специализаций исполнителей.
Поля документа категории: name (название категории, например, "Дизайнер", "Back-end разработчик"), description (описание категории или навыков, может быть необязательным).
(От финансовых сущностей отказано: в структуре данных нет коллекций/полей для балансов, транзакций, бюджетов или выплат. Например, поле balance у пользователя, коллекции transactions или финансовые поддокументы в проектах удалены.)
Уведомления и события
Платформа Taska оповещает пользователей о важных событиях, связанных с проектами и их участием. Уведомления генерируются в следующих случаях (не считая финансовых операций):
Изменение статуса или этапа проекта: например, проект запущен, этап завершён, проект завершён – уведомляются заказчик, команда или ответственные, для кого это актуально.
Новые приглашения в проект: исполнитель получает уведомление о новом приглашении в команду проекта; пресейл/ПМ получают уведомление, когда исполнитель ответил на приглашение (принял или отклонил).
Чаты и сообщения: если в проектном чате появляется новое сообщение и пользователь не находится активно на странице чата, ему может прийти уведомление (например, push-уведомление) о новом сообщении.
Изменения на доске задач: например, назначение задачи на пользователя или изменение статуса задачи – при необходимости ответственный исполнитель или ПМ могут получать уведомления.
Технические оповещения: системные уведомления, напоминания, либо сообщения об ошибках/сбоях (для админов).
Уведомления хранятся в коллекции notifications каждого пользователя и могут доставляться через интерфейс (список уведомлений в личном кабинете), а также дублироваться по email или в мессенджеры при интеграции (например, оповещения в Telegram, если подключено). Пользователь может пометить уведомление как прочитанное, после чего оно перестает отображаться как новое (см. эндпоинт /notifications/mark-read). Все описанные события синхронизируются в реальном времени. Например, при принятии исполнителем приглашения менеджер сразу увидит обновление статуса заявки и получит уведомление; при добавлении комментария или задач – другие участники, имеющие доступ, сразу увидят эти изменения без перезагрузки страницы.
Заключение
Данный документ описывает необходимый набор API эндпоинтов и механизмов реального времени для backend платформы Taska, а также структуру хранения данных в Firestore. Предложенное решение учитывает все роли пользователей (заказчик, исполнитель, ПМ, пресейл, супер-админ) и основные сценарии работы системы – от подачи заявки на проект и формирования команды до совместной работы над задачами и общения. Реализация на базе Firebase существенно упрощает обеспечение мгновенной синхронизации данных и масштабируемости, а четкое разграничение прав доступа и эндпоинтов по ролям гарантирует безопасность и консистентность данных.